\subsection{Разработка палитры компонентов}
\label{sec:development:component_palett}

Для инициализации компонента палитры были использованы компоненты библиотеки Webix. Для отображения разных вкладок на панели использвался компонент TabView, а для отображения данных и источника <<перетягивания>> комопннетов использовался компонент DataView, так как имеет встроенные возможности для работы с алгоритмом Drag-n-drop. 

\subsubsection{}Способ предоставления компонентов
\

Каждой вкладке соответствует свой DataView, отображающий дозированные согласно названию вкладки данные, управляет отображением же TabView. Далее будет представлен основной код палитры компонентов.

\begin{lstlisting}
import getAllTabConfig from './palletTabs/all';
import { getPresetsTabConfig } from './palletTabs/presetsTab';

const getDefaultComponentPalletLayout = dataContent => ({
  rows: [
    {
      view: 'search', // Webix component name
      placeholder: 'Search 1,000,000 images...' // default output
    },
    {
      view: 'tabview',

      // child views container
      cells: [
        {
          header: 'All', // tab's output name 
          body: getAllTabConfig(dataContent) // tab's content
        },
        {
          header: 'Presets',
          body: getPresetsTabConfig()
        },
        ...componentContainers(dataContent) // rest child components
      ]
    }
  ]
});
\end{lstlisting}

Содержимое массива, возвращаемого функцией componentContainers являются DataView компоненты, содержание каждого из которых соответствует выбранной вкладке. Конфиг каждой из вкладок выглядит следующим образом:

\begin{lstlisting}
{
  header: 'Components', // selected tab's name
  body: {
    view: 'dataview', // webix component name
    template: DATAVIEW_TEMPLATE, // output mapping template
    id: COMPONENTS_DATAVIEW_CONFIG,
    xCount: 3, // row size
    drag: 'source', // special property for Drag-and-drop
    minHeight: 200,
    data: data.components // data for mapping and output
  }
}
\end{lstlisting}

Каждый DataView компонент отвечает за отображение своей части данных, а указание свойства <<drag: 'source'>> предоставляет возможность использовать компонент как источник данных (пункта <<тащи>> или <<drag>>) для реализации алгоритма Drag-n-drop.

Загрузка содержимого DataView компонентов -- преопределенных конфигураций графических компонентов, осуществляется самим Component-Pallet при его инициализации путем, регламентированным библиотекой Webix. При получении результата AJAX-запроса, данные запроса разбиваются на группы, соответствующие существующим вкладкам, и обрабатываются инструментами отображения.

Применение кастомной конфигурации к базовому компоненту осуществляется путем применения метода protoUI глобального объекта webix к конфигурации нашего компонента Component-Pallet и базовым классам, предоставляемым библиотекой Webix:
\begin{itemize}
    \item webix.IdSpace -- для изоляции содержимого;
    \item webix.ui.layout -- для доступа к функциональности базового лэйаута.
\end{itemize}

\begin{lstlisting}
webix.protoUI(
  componentPalletConfig, // custom config
  webix.IdSpace, // webix spacer component's class
  webix.ui.layout // webix default component's class
);
\end{lstlisting}

По умолчанию предполагается, что в получаемом в результате запроса JavaScript-объекте должны быть поля: layouts, components и card -- три вида лэйаутов. Однако, эти параметры могут быть изменены разработчиком, интегрирующим данное програмнное средство в свой проект.

\subsubsection{}Пресеты
\

В палитре компонентов, как указывалось ранее, доступна возможность загрузки и применения пресетов -- предопределенных наборов компонентов, которые были созданы и предоставлены разработчиками или, например, другими пользователями.

Доступ к пресетам осуществляется через соответствующую вкладку <<Presets>>. Лист пресетов получает их конфигурации из объекта, реализующего доступ к данным в библиотеке Webix -- DataCollection.

Сохранение текущей конфигурации осуществляется путем сериализации содержимого грида. Для этого вызывается метод объекта грида getSerializedCollection, логика которого будет рассмотрена позднее.

Удаление пресета из списка осуществляется путем удаления пресета из коллекции, к которой <<привязан>> список пресетов. Путем простой фильтрации по условию неравенства уникальному свойству удаляемого пресета и осуществляется процесс удаления.

Применение пресета удаляет все содержимое грида, а затем туда в качестве дочерних элементов добавляется содержимое выбранного пресета. 
